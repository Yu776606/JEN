<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>äº’å‹•è§’åº¦å­¸ç¿’</title>
    <!-- è¼‰å…¥ Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ä½¿ç”¨ 'Inter' å­—é«” */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* è®“ç•«å¸ƒæœ‰æ›´å¥½çš„è§¸æ§é«”é©— */
        canvas {
            touch-action: none;
            cursor: pointer;
        }
    </style>
</head>
<body class="bg-blue-50 min-h-screen flex items-center justify-center p-4">
    <div class="w-full max-w-5xl mx-auto">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-blue-800">ä¾†å­¸è§’åº¦å§ï¼</h1>
            <p class="text-lg text-gray-700 mt-2">æ‹–å‹•å½©è‰²çš„é»é»ï¼Œçœ‹çœ‹è§’åº¦æœ‰ä»€éº¼è®ŠåŒ–ï¼Ÿ</p>
        </header>

        <!-- å…©å€‹è§’åº¦çš„æ¯”è¼ƒå€åŸŸ -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
            
            <!-- è§’åº¦ 1 (é‚Šæ¯”è¼ƒçŸ­) -->
            <div class="bg-white p-6 rounded-2xl shadow-lg">
                <h2 class="text-2xl font-bold text-center text-blue-700 mb-4">è§’åº¦ 1</h2>
                <canvas id="angleCanvas1" class="w-full h-64 bg-gray-100 rounded-lg border-2 border-gray-200"></canvas>
                <p id="angleDisplay1" class="text-center text-3xl font-bold text-blue-700 mt-4">è§’åº¦ï¼š0Â°</p>
            </div>

            <!-- è§’åº¦ 2 (é‚Šæ¯”è¼ƒé•·) -->
            <div class="bg-white p-6 rounded-2xl shadow-lg">
                <h2 class="text-2xl font-bold text-center text-purple-700 mb-4">è§’åº¦ 2</h2>
                
                <!-- *** æ–°å¢æ»‘æ¡¿ *** -->
                <div class="mb-4 px-2">
                    <label for="lengthSlider" class="block text-sm font-medium text-gray-700">èª¿æ•´é‚Šé•·ï¼š</label>
                    <input type="range" id="lengthSlider" min="0.3" max="1.0" step="0.05" value="0.7" class="w-full h-2 bg-purple-200 rounded-lg appearance-none cursor-pointer accent-purple-600">
                </div>

                <canvas id="angleCanvas2" class="w-full h-64 bg-gray-100 rounded-lg border-2 border-gray-200"></canvas>
                <p id="angleDisplay2" class="text-center text-3xl font-bold text-purple-700 mt-4">è§’åº¦ï¼š0Â°</p>
            </div>
        </div>

        <!-- è€å¸«çš„å°æç¤º -->
        <div class="mt-8 bg-yellow-100 border-l-4 border-yellow-500 text-yellow-800 p-6 rounded-lg shadow-md">
            <h3 class="font-bold text-xl mb-2">ğŸ’¡ è€å¸«çš„å°æç¤ºï¼š</h3>
            <p class="text-lg">ä½ ç™¼ç¾äº†å—ï¼Ÿã€Œè§’åº¦ 1ã€çš„é‚Šæ¯”è¼ƒçŸ­ï¼Œã€Œè§’åº¦ 2ã€çš„é‚Šæ¯”è¼ƒé•·ã€‚ä½†æ˜¯ï¼Œè§’åº¦çš„å¤§å°æ˜¯çœ‹ã€Œé–‹å£ã€æœ‰å¤šå¤§ï¼Œè·Ÿé‚Šé‚Šçš„é•·çŸ­æ²’æœ‰é—œä¿‚å–”ï¼è©¦è‘—æŠŠå…©å€‹è§’åº¦èª¿æˆä¸€æ¨£çš„åº¦æ•¸çœ‹çœ‹ï¼</p>
        </div>
    </div>

    <script>
        window.addEventListener('load', () => {
            /**
             * å»ºç«‹ä¸€å€‹å¯äº’å‹•çš„è§’åº¦ç•«å¸ƒ
             * @param {string} canvasId - ç•«å¸ƒçš„ ID
             * @param {string} displayId - é¡¯ç¤ºè§’åº¦åº¦æ•¸çš„å…ƒç´  ID
             * @param {number} initialSideLengthFactor - è§’åº¦é‚Šçš„ *åˆå§‹* é•·åº¦å› å­ (ç›¸å°æ–¼ç•«å¸ƒå¯¬åº¦)
             * @param {string} color - è§’åº¦çš„ä¸»é¡Œé¡è‰²
             */
            function createAngleInteractor(canvasId, displayId, initialSideLengthFactor, color) {
                const canvas = document.getElementById(canvasId);
                const angleDisplay = document.getElementById(displayId);
                const ctx = canvas.getContext('2d');

                // è™•ç†é«˜DPIè¢å¹•
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                ctx.scale(dpr, dpr);

                // èª¿æ•´ç•«å¸ƒå…§çš„å°ºå¯¸
                const logicalWidth = rect.width;
                const logicalHeight = rect.height;
                
                // *** ä¿®æ­£ ***ï¼šå°‡ sideLengthFactor è¨­ç‚ºå¯è®Šå‹•çš„ let
                let sideLengthFactor = initialSideLengthFactor;
                let sideLength = logicalWidth * sideLengthFactor; 

                // è§’åº¦çš„é ‚é» (æ”¾åœ¨å·¦ä¸‹è§’)
                const vertex = { x: logicalWidth * 0.2, y: logicalHeight * 0.8 };
                // æ‹–æ›³åœ“é»çš„åŠå¾‘
                const handleRadius = 12;
                
                let angle = Math.PI / 3; // åˆå§‹è§’åº¦ (60 åº¦)
                let isDragging = false;
                let handle = { x: 0, y: 0 };

                // ç¹ªè£½æ‰€æœ‰å…ƒç´ 
                function draw() {
                    // *** ä¿®æ­£ ***ï¼šåœ¨æ¯æ¬¡é‡ç¹ªæ™‚éƒ½é‡æ–°è¨ˆç®—é‚Šé•·
                    sideLength = logicalWidth * sideLengthFactor;

                    // æ¸…é™¤ç•«å¸ƒ
                    ctx.clearRect(0, 0, canvas.width, canvas.height);

                    // æ ¹æ“šè§’åº¦è¨ˆç®—æ‹–æ›³é»çš„ä½ç½®
                    handle.x = vertex.x + sideLength * Math.cos(-angle); // Yè»¸åè½‰ï¼Œè§’åº¦ä¹Ÿåè½‰
                    handle.y = vertex.y + sideLength * Math.sin(-angle);

                    // 1. ç¹ªè£½éœæ­¢çš„é‚Š (æ°´å¹³ç·š)
                    ctx.beginPath();
                    ctx.moveTo(vertex.x, vertex.y);
                    ctx.lineTo(vertex.x + sideLength, vertex.y);
                    ctx.strokeStyle = '#333'; // é»‘è‰²
                    ctx.lineWidth = 6;
                    ctx.lineCap = 'round';
                    ctx.stroke();

                    // 2. ç¹ªè£½å¯å‹•çš„é‚Š
                    ctx.beginPath();
                    ctx.moveTo(vertex.x, vertex.y);
                    ctx.lineTo(handle.x, handle.y);
                    ctx.strokeStyle = color; // ä¸»é¡Œè‰²
                    ctx.lineWidth = 6;
                    ctx.lineCap = 'round';
                    ctx.stroke();

                    // 3. ç¹ªè£½è§’åº¦å¼§å½¢
                    ctx.beginPath();
                    ctx.moveTo(vertex.x, vertex.y);
                    ctx.arc(vertex.x, vertex.y, sideLength * 0.4, 0, -angle, true); // é€†æ™‚é‡
                    ctx.closePath();
                    ctx.fillStyle = color + '40'; // å¸¶é€æ˜åº¦çš„ä¸»é¡Œè‰²
                    ctx.fill();

                    // 4. ç¹ªè£½æ‹–æ›³åœ“é»
                    ctx.beginPath();
                    ctx.arc(handle.x, handle.y, handleRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = color;
                    ctx.fill();
                    ctx.strokeStyle = 'white'; // ç™½è‰²å¤–æ¡†
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    // æ›´æ–°é¡¯ç¤ºçš„åº¦æ•¸
                    let degrees = (angle * 180 / Math.PI).toFixed(0);
                    angleDisplay.textContent = `è§’åº¦ï¼š${degrees}Â°`;
                }

                // å–å¾—æ»‘é¼ /è§¸æ§åœ¨ç•«å¸ƒä¸Šçš„ç›¸å°ä½ç½®
                function getPos(evt) {
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = logicalWidth / rect.width;
                    const scaleY = logicalHeight / rect.height;

                    let clientX, clientY;
                    if (evt.touches) {
                        clientX = evt.touches[0].clientX;
                        clientY = evt.touches[0].clientY;
                    } else {
                        clientX = evt.clientX;
                        clientY = evt.clientY;
                    }
                    return {
                        x: (clientX - rect.left) * scaleX,
                        y: (clientY - rect.top) * scaleY
                    };
                }

                // è¨ˆç®—å…©é»ä¹‹é–“çš„è·é›¢
                function getDistance(p1, p2) {
                    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
                }

                // æ›´æ–°è§’åº¦
                function updateAngle(pos) {
                    if (!pos) return;
                    // ä½¿ç”¨ atan2 è¨ˆç®—è§’åº¦
                    angle = -Math.atan2(pos.y - vertex.y, pos.x - vertex.x);
                    
                    // é™åˆ¶è§’åº¦åœ¨ 1Â° åˆ° 179Â° ä¹‹é–“
                    const minAngle = 0.017; // ç´„ 1 åº¦
                    const maxAngle = Math.PI - 0.017; // ç´„ 179 åº¦
                    if (angle < minAngle) angle = minAngle;
                    if (angle > maxAngle) angle = maxAngle;

                    draw();
                }

                // --- äº‹ä»¶ç›£è½ ---

                function onStart(evt) {
                    const pos = getPos(evt);
                    if (getDistance(pos, handle) <= handleRadius * 1.5) { // æ”¾å¤§è§¸æ§ç¯„åœ
                        isDragging = true;
                        canvas.style.cursor = 'grabbing';
                    }
                }

                // *** ç¨‹å¼ç¢¼ä¿®æ­£ ***
                // æ¢å¾© onMove å‡½æ•¸çš„æ­£ç¢ºå…§å®¹å’Œçµæ§‹
                function onMove(evt) {
                    if (isDragging) {
                        updateAngle(getPos(evt));
                    }
                }

                function onEnd() {
                    isDragging = false;
                    canvas.style.cursor = 'pointer';
                }

                // æ»‘é¼ äº‹ä»¶
                canvas.addEventListener('mousedown', onStart);
                canvas.addEventListener('mousemove', onMove);
                canvas.addEventListener('mouseup', onEnd);
                canvas.addEventListener('mouseleave', onEnd);

                // è§¸æ§äº‹ä»¶
                canvas.addEventListener('touchstart', onStart);
                canvas.addEventListener('touchmove', onMove);
                canvas.addEventListener('touchend', onEnd);
                canvas.addEventListener('touchcancel', onEnd);
                
                // åˆå§‹ç¹ªè£½
                draw();

                // *** ç¨‹å¼ç¢¼ä¿®æ­£ ***
                // ç¢ºä¿ return èªå¥åœ¨ createAngleInteractor å‡½æ•¸çš„é ‚å±¤
                return {
                    updateSideLengthFactor: (newFactor) => {
                        if (newFactor >= 0.3 && newFactor <= 1.0) { // é™åˆ¶åœ¨æ»‘æ¡¿ç¯„åœå…§
                            sideLengthFactor = newFactor;
                            draw(); // ç”¨æ–°çš„é‚Šé•·é‡æ–°ç¹ªè£½
                        }
                    },
                    getAngle: () => (angle * 180 / Math.PI).toFixed(0)
                };
            } // createAngleInteractor å‡½æ•¸çš„çµæŸå¤§æ‹¬è™Ÿ

            // å»ºç«‹ è§’åº¦ 1 (çŸ­é‚Š, è—è‰²)
            // é€™è£¡ä¸éœ€è¦å„²å­˜å›å‚³å€¼ï¼Œå› ç‚ºå®ƒä¸æœƒè®Šå‹•
            createAngleInteractor('angleCanvas1', 'angleDisplay1', 0.4, '#3b82f6');

            // å»ºç«‹ è§’åº¦ 2 (é•·é‚Š, ç´«è‰²)
            // *** ä¿®æ­£ ***ï¼šå„²å­˜å›å‚³çš„ interactor ç‰©ä»¶
            const angle2Interactor = createAngleInteractor('angleCanvas2', 'angleDisplay2', 0.7, '#8b5cf6');
            
            // *** æ–°å¢ ***ï¼šç‚ºæ»‘æ¡¿åŠ ä¸Šäº‹ä»¶ç›£è½
            const slider = document.getElementById('lengthSlider');
            if (slider) {
                slider.addEventListener('input', (evt) => {
                    const newFactor = parseFloat(evt.target.value);
                    // å‘¼å«æ›´æ–°å‡½å¼
                    angle2Interactor.updateSideLengthFactor(newFactor);
                });
            }
            
            // è™•ç†è¦–çª—å¤§å°è®ŠåŒ–
            window.addEventListener('resize', () => {
                 // ç°¡å–®åœ°é‡æ–°è¼‰å…¥ä»¥é‡æ–°è¨ˆç®—DPRå’Œå°ºå¯¸
                 // åœ¨æ›´è¤‡é›œçš„æ‡‰ç”¨ä¸­ï¼Œæˆ‘å€‘æœƒé‡æ–°è¨ˆç®—ä¸¦é‡ç¹ª
                window.location.reload();
            });
        });
    </script>
</body>
</html>